GitHub - csabapalfi/awesome-pagespeed-metrics: Metrics to help understand page speed and user experience Skip to content  Documentation GitHub Skills Blog Solutions By company size Enterprises Small and medium teams Startups Nonprofits By use case DevSecOps DevOps CI/CD View all use cases By industry Healthcare Financial services Manufacturing Government View all industries View all solutions Resources Topics AI DevOps Security Software Development View all Explore Learning Pathways Events & Webinars Ebooks & Whitepapers Customer Stories Partners Executive Insights Open Source GitHub Sponsors Fund open source developers The ReadME Project GitHub community articles Repositories Topics Trending Collections Enterprise Enterprise platform AI-powered developer platform Available add-ons GitHub Advanced Security Enterprise-grade security features Copilot for business Enterprise-grade AI features Premium Support Enterprise-grade 24/7 support Pricing Search or jump to... Search code, repositories, users, issues, pull requests... Search Clear Search syntax tips Provide feedback We read every piece of feedback, and take your input very seriously. Include my email address so I can be contacted Cancel Submit feedback Saved searches Use saved searches to filter your results more quickly Name Query To see all available qualifiers, see our documentation. Cancel Create saved search Sign in Sign up Reseting focus You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. Dismiss alert csabapalfi / awesome-pagespeed-metrics Public Notifications You must be signed in to change notification settings Fork 27 Star 681 Metrics to help understand page speed and user experience License View license 681 stars 27 forks Branches Tags Activity Star Notifications You must be signed in to change notification settings Code Issues 2 Pull requests 8 Actions Projects 0 Security Insights Additional navigation options Code Issues Pull requests Actions Projects Security Insights csabapalfi/awesome-pagespeed-metrics masterBranchesTagsGo to fileCodeFolders and filesNameNameLast commit messageLast commit dateLatest commit History119 Commits.github/workflows.github/workflows .gitignore.gitignore CONTRIBUTING.mdCONTRIBUTING.md LICENSE.txtLICENSE.txt README.mdREADME.md code-of-conduct.mdcode-of-conduct.md package.jsonpackage.json yarn.lockyarn.lock View all filesRepository files navigationREADMECode of conductLicenseAwesome Page Speed Metrics Metrics to help understand page speed and user experience. If you're just getting started check out web.dev/metrics first. Contents Concepts Lab Data (Synthetic Measurements) Field Data (Real User Monitoring - RUM) Critical rendering path Long tasks User-centric metrics Rendering metrics First Contentful Paint (FCP) Largest Contentful Paint (LCP) Cumulative Layout Shift (CLS) Visually Complete Speed Index (Hero) Element Timing Interactivity metrics Time to Interactive (TTI) Total Blocking Time (TBT) First Input Delay (FID) Max Potential First Input Delay Network metrics DNS latency TCP and SSL/TLS latency Time to First Byte (TTFB) Transferred bytes Other metrics Google PageSpeed Insights score User Timing Server Timing Frame rate DOMContentLoaded window.load Concepts Lab Data (Synthetic Measurements) Make a request to your page with a tool and evaluate performance. Be sure to make it realistic (e.g. by throttling network and CPU) and reduce noise (e.g. by running multiple times). Lighthouse - A tool built on Google Chrome to audit web pages. You can run it from Chrome DevTools, a Chrome Extension or from the command line (even with headless Chrome). Google PageSpeed Insights - Free and hosted Lighthouse reporting (and more) by Google. WebpageTest - Free and hosted web performance testing (also an open source project). Sitespeed.io - A set of open source performance monitoring tools. Calibre - Web performance monitoring SaaS. treo.sh - Web performance monitoring SaaS. SpeedCurve - Web performance monitoring SaaS. AwesomeTechStack - Website awesomeness monitoring Tool. Field Data (Real User Monitoring - RUM) Collect performance data from real users visiting your page. Be mindful of the actual overhead, as it runs in your user's browser and watch out for browser support of more recent metrics (e.g. compared to your user-base). Performance tracking with Google Analytics (GA) Chrome User Experience Report (CrUX) Load abandonment - Track visibilitychange to account for survivorship bias. SpeedCurve LUX - Real User Monitoring SaaS. Akamai mPulse - Real User Monitoring SaaS. Sematext Experience - Real User Monitoring SaaS. Perfume.js - Open Source Library to collect Field Data. Web Vitals - Open Source Library to collect Field Data. Vercel Analytics - Real User Monitoring based on Web Vitals. Critical rendering path The critical rendering path is everything that happens between receiving network bytes and rendering something on the screen. To optimize any rendering metrics like First Contentful Paint (FCP) or Speed Index you have to understand how the critical rendering path works. Critical rendering path Long tasks The browser Main Thread that handles user input is also the one executing JavaScript (among many other things). Blocking the Main Thread for too long can make your page unresponsive. A user perceives any visual change within 100ms as instant. Any task blocking the Main Thread by taking longer than 50ms is considered a long task (as it might make the browser unresponsive to user input). To optimize interactivity metrics like Total Blocking Time (TBT) and First Input Delay (FID) you have to understand long tasks and how to avoid them as much as possible. Spec - Long Tasks Blogpost - Tracking CPU with Long Tasks API User-centric metrics It's important to track metrics relevant to users and their experience. To measure the perceived performance we can choose metrics by framing them around a few key questions. Docs - User-centric Performance Metrics - web.dev Is it happening? - Did the navigation start successfully? Has the server responded? (e.g FCP) Is it useful/meaningful? - Has enough content rendered that users can engage with it? (e.g. LCP) Is it usable - Can users interact with the page, or is it still busy loading? (e.g TBT) Is it delightful/smooth? - Are the interactions smooth and natural, free of lag and jank? Rendering metrics First Contentful Paint (FCP) The First Contentful Paint (FCP) metric measures the time from when the page starts loading to when any part of the page's content is rendered on the screen. For this metric, "content" refers to text, images (including background images), <svg> elements, or non-white <canvas> elements. Lab: Lighthouse Field: Chrome 60+, CrUX Docs - FCP - web.dev Spec - Paint Timing - W3C Largest Contentful Paint (LCP) The Largest Contentful Paint (LCP) metric reports the render time of the largest content element visible within the viewport. Lab: Lighthouse/WPT Field: Chrome 77+ Docs - LCP - web.dev Spec - LCP - W3C Cumulative Layout Shift (CLS) A layout shift occurs any time a visible element changes its position from one frame to the next. CLS measures the sum total of all individual layout shift scores for every unexpected layout shift that occurs during the entire lifespan of the page. Lab: Lighthouse/WPT Field: Chrome 77+ Docs - CLS - web.dev Spec - Layout Instability API - W3C Visually Complete The Visually Complete is the time from the start of the initial navigation until the visible (above the fold) part of your page is no longer changing. (e.g. WPT measures this using a color histogram of the page based on video/screenshots recording). Lab: WPT Field: N/A Docs - Visually Complete - WPT Speed Index Speed Index shows how quickly the contents of a page are visibly populated (lower numbers are better). This is done by frequently measuring visual completeness during loading. The quicker the page is more visually complete the lower the value. Lab: Lighthouse, WPT (but slightly different spec) Field: N/A Docs - Speed Index - web.dev Docs - Speed Index - WPT Talk - Speed Perception and Lighthouse (Hero) Element Timing Element Timing captures when specific elements are painted by the browser. Hero elements can be defined as the largest h1, img or background image (or custom ones using the Element Timing API) Lab: WPT Field: Chrome 77+ Docs - Last Painted Hero - WPT Spec - Element Timing API Blogpost - Hero Element Timing - SpeedCurve Interactivity metrics Time to Interactive (TTI) Time to interactive is the time it takes for the page to become fully interactive (as in Main Thread quiet for 5s). Sometimes called Consistently Interactice and not to be confused with First Interactive or First CPU Idle. (Warning: one of the most confusing and misunderstood metrics). Lab: Lighthouse, WPT Field: Not recommended as users interacting with your page can skew field measurements of TTI Docs - TTI - web.dev Spec - TTI - Lighthouse Blogpost - TTI Total Blocking Time (TBT) The Total Blocking Time (TBT) metric measures the total amount of time between First Contentful Paint (FCP) and Time to Interactive (TTI) where the main thread was blocked for long enough to prevent input responsiveness. Lab: Lighthouse Field: N/A Docs - TBT - web.dev First Input Delay (FID) First Input Delay (FID) measures the time from when a user first interacts with your site to the time when the browser is actually able to respond to that interaction. An interaction can be when users click a link, tap on a button, or use a custom, JavaScript-powered control. Lab: N/A (as it requires the user to interact with the page) Field: IE9+ (and Safari, Chrome, Firefox) (with polyfill - 0.4KB) Docs - FID - web.dev Polyfill - FID Max Potential First Input Delay The maximum potential First Input Delay that your users could experience. Basically equals to the duration of the longest long task on the browser Main Thread. Lab: Lighthouse Field: N/A Docs - Max Potential FID - web.dev Network metrics Network timing field data can uncover a non-optimized TLS setup, slow DNS lookups or server side processing and issues with CDN configuration. See also a separate section about measuring transferred bytes. Blogpost - Navigation and Resource Timing Spec - Navigation Timing Spec - Resource Timing DNS latency Lab: DNS performance testing tools Field: IE9+, Safari 9+ // Measuring DNS lookup time var pageNav = performance.getEntriesByType("navigation")[0]; var dnsTime = pageNav.domainLookupEnd - pageNav.domainLookupStart; TCP and SSL/TLS latency Lab: See Qualys SSL Labs for an audit Field: IE9+, Safari 9+ // Quantifying total connection time var pageNav = performance.getEntriesByType("navigation")[0]; var connectionTime = pageNav.connectEnd - pageNav.connectStart; var tlsTime = 0; // <-- Assume 0 by default // Did any TLS stuff happen? if (pageNav.secureConnectionStart > 0) { // Awesome! Calculate it! tlsTime = pageNav.connectEnd - pageNav.secureConnectionStart; } Time to First Byte (TTFB) Lab: most server load testing tools report this Field: IE9+, Safari 9+ var ttfb = pageNav.responseStart - pageNav.requestStart; Transferred bytes You can measure the byte weight of your assets with a number of tools. You would normally track these Lab only as the numbers are usually the same in the Field (but be mindful of device type or geographical location specific pages). Measuring own (and third-party) JavaScript bytes is crucial as JavaScript is the main cause of high TTI or FID values. Lab: Lighthouse (budgets), Sitespeed.io, custom tools Field: N/A - but numbers usually the same as in Lab Sitespeed.io PageXray Lighthouse Performance Budgets Can You Afford It?: Real-world Web Performance Budgets Which third party scripts are most excessive Other metrics Google PageSpeed Insights score About PageSpeed Insights What's in the Google PageSpeed score How Google Pagespeed works User Timing The User Timing API allows the developer to create application specific timestamps that are part of the browser's performance timeline. e.g. you can create a user timing mark to measure when your JS has loaded for a specific component on the page. Lab: Lighthouse, WPT Field: IE 10+, Safari 11+ (and Chrome, Firefox of course) Spec - User Timing Server Timing Surface any backend server timing metrics (e.g. database latency, etc.) in the developer tools in the user's browser or in the PerformanceServerTiming interface. Docs - Server Timing Frame rate The frame rate is the frequency at which the browser can display frames. A frame represents the amount of work a browser does in one event loop iteration such as processing DOM events, resizing, scrolling, rendering, CSS animations, etc. A frame rate of 60 fps (frames per second) is a common target for a good responsive user experience. This means the browser should process a frame in about 16.7 ms. Lab: Chrome and FF Devtools Field: No browser implements the Frame Timing API yet but you can roll your own fps meter using requestAnimationFrame Docs - Frame Timing API Docs - Chrome Devtools - FPS Docs - Firefox Developer Tools - Frame rate DOMContentLoaded Docs - DOMContentLoaded window.load Docs - window.load License To the extent possible under law, Csaba Palfi has waived all copyright and related or neighboring rights to this work. About Metrics to help understand page speed and user experience Topics performance awesome web-performance metrics awesome-list perfmatters page-speed Resources Readme License View license Code of conduct Code of conduct Activity Stars 681 stars Watchers 33 watching Forks 27 forks Report repository Releases No releases published Packages 0 No packages published Contributors 6 Footer  2025 GitHub, Inc. Footer navigation Terms Privacy Security Status Docs Contact Manage cookies Do not share my personal information You cant perform that action at this time.