GitHub - thoughtspile/awesome-tiny-js: 🤏 A collection of tiny JS libraries (under 2 kB) to put your bundle on a diet Skip to content Navigation Menu Toggle navigation Sign in Product GitHub Copilot Write better code with AI GitHub Advanced Security Find and fix vulnerabilities Actions Automate any workflow Codespaces Instant dev environments Issues Plan and track work Code Review Manage code changes Discussions Collaborate outside of code Code Search Find more, search less Explore All features Documentation GitHub Skills Blog Solutions By company size Enterprises Small and medium teams Startups Nonprofits By use case DevSecOps DevOps CI/CD View all use cases By industry Healthcare Financial services Manufacturing Government View all industries View all solutions Resources Topics AI DevOps Security Software Development View all Explore Learning Pathways Events & Webinars Ebooks & Whitepapers Customer Stories Partners Executive Insights Open Source GitHub Sponsors Fund open source developers The ReadME Project GitHub community articles Repositories Topics Trending Collections Enterprise Enterprise platform AI-powered developer platform Available add-ons GitHub Advanced Security Enterprise-grade security features Copilot for business Enterprise-grade AI features Premium Support Enterprise-grade 24/7 support Pricing Search or jump to... Search code, repositories, users, issues, pull requests... Search Clear Search syntax tips Provide feedback We read every piece of feedback, and take your input very seriously. Include my email address so I can be contacted Cancel Submit feedback Saved searches Use saved searches to filter your results more quickly Name Query To see all available qualifiers, see our documentation. Cancel Create saved search Sign in Sign up Reseting focus You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. Dismiss alert thoughtspile / awesome-tiny-js Public Notifications You must be signed in to change notification settings Fork 13 Star 724 🤏 A collection of tiny JS libraries (under 2 kB) to put your bundle on a diet License CC0-1.0 license 724 stars 13 forks Branches Tags Activity Star Notifications You must be signed in to change notification settings Code Issues 3 Pull requests 0 Actions Projects 0 Security Insights Additional navigation options Code Issues Pull requests Actions Projects Security Insights thoughtspile/awesome-tiny-js mainBranchesTagsGo to fileCodeFolders and filesNameNameLast commit messageLast commit dateLatest commit History40 Commits.github/workflows.github/workflows imgimg srcsrc awesome-logo.pngawesome-logo.png contributing.mdcontributing.md incubate.mdincubate.md licenselicense readme.mdreadme.md wip.mdwip.md View all filesRepository files navigationREADMECC0-1.0 licenseAwesome Tiny JS Tiny front-end libraries to put your bundle on a diet. Rules: Size is under 2 kB-ish, min + gzip, with all dependencies, except where noted. For multi-purpose libraries, the size of a useful subset must be under 2 kB-ish. Useful client-side. I haven't figured out participation rules for node-only libraries, and I'm not too worried about them. Second-level libraries only allowed for React, Vue, Angular, svelte. 100+ GitHub stars or 500+ weekly npm installs to focus on tools with some community review. No zero-JS (CSS- or type-only) libraries. It's not awesome-css or something. Contents UI Frameworks Event Emitters State Managers Signals Reactive Programming Routers and URL Utils API Layer I18N Dates and Time Generic Utilities Validation Unique ID Generation Colors Touch Gestures Text Search UI Frameworks UI frameworks (libraries?) provide declarative templates, event bindings, and observable state to update the view. I've been generous and expanded the size limit for this category to 4.5 kB (if you're boring, count them as 2 libraries), but also increased the star limit to 2K. preact - React-like API (pre-hooks). Cool ecosystem of similarly tiny tools and components. Highly recommended. The following libraries are small and cool, but note they're about 500x less popular than preact. Kudos for deconstrucing the very essence of a "framework": hyperapp - vDOM framework with pure JS syntax and immutable state, redom - Hyperapp-style templates with imperative event listeners and updates, Now, for the openly experimental UI libraries: fre - React-like library with hooks and concurrency, van - vDOM-based framework optimized for no-build setups, superfine - Hyperapp with state & effect hooks removed, arrowjs - Tagged templates + reactive data, And if being declarative is not your thing: umbrella - jQuery-style DOM manipulation library, Event Emitters Event emitter pattern is fairly easy to implement yourself, but why bother when you have these cool tools? With an arms race to build the smallest one, the limit is 0.5 kB. mitt - Plain event emitter that I use on most projects, nanoevents - Nicer unsubscribe API, but no * event, onfire.js - Also has .once method, State Managers State managers combine observable state with actions and framework bindings, intended for app-wide state. zustand - Simple stores with pleasant actions and selectors. Vanilla , React nanostores - Modular store with good tree-shaking support, vanilla, + React extra. Supports all the top frameworks. exome - Atomic stores with lots of framework connectors, + React extra. Supports all the top frameworks. storeon - Minimal redux-styled store with lots of framework connectors, . React extra + Vue, Svelte, Angular. unistore - Centralized store with actions, + React teaful - Store with useState-like API, , including React / preact connector. Signals A signal-styled state manager provides observable values (aka signals), derived values and effects. @preact/signals - The OG signals from preact core, with react integration. usignal - A smaller signal implementation, hyperactiv - 4 functions to make objects observable and listen to changes, flimsy - Signals from Solid (it almost fit into UI frameworks category itself). Author warning: it's probably buggy. Honorable mention: oby could make it if it had tree-shaking, but otherwise is around 7 kB. Reactive Programming Another well-known state management approach is reactive programmning — operating on event streams, applying filters and transforms to end up with an observable value. Think RxJS, but tiny: flyd - Rx-styled event streams, callbag-basics - Rx-style event streams, Routers and URL Utils Do stuff on URL / history changes, with path matching and parsing: wouter - Declarative router for React / preact, , also available as a standalone hook: @nanostores/router - Routes as a nanostores store (framework-agnostic), navaid - History-based observable router, Just want to parse or match URL paths without observing them? Here you go: matchit - Route parser and matcher in regexparam - Convert path to regexp in qss - Parse querystrings in . Not sure you need it, URL API support is good. API Layer fetch API has some boilerplate associated with it: serialize & parse data, reject on non-200 response, etc. These tiny packages handle it for you: redaxios - Drop-in axios replacement for modern browsers, wretch - Chainable API with error processing and lots of extra plugins, gretchen - Chainable API with type-safe errors, If for some reason you still need a fetch polyfill, try this one: unfetch - Loose fetch polyfill, I18N A map of strings might seem enough to translate an app, but these tools also handle interpolation and some extra goodies: @nanostores/i18n - Detect locale, load dictionaries, format dates / numbers, including nanostores. eo-locale - Interpolation and dates / numbers, , or with react bindings. rosetta - Bare-bones template strings ({{hello}}, {{username}}) and custom functions for everyting else, lingui - Small core with template strings, Dates and Time Date and time manipulation in pure JS is verbose. Luckily, two of the top date libraries have sensible size: date-fns - Not tiny as a whole, but most functions are under 1 kB each (format and parse are quite heavy). dayjs - Almost moment.js-compatible API, covers most use cases, And some more packages that only do formatting: tinytime - Simple date / time formatter: {h}:{mm} -> 9:33, tinydate - Date / time formatter, only supports padded numeric output (September -> 09), time-stamp - More of the same, ms - Parse & format ms durations, e.g. "1m" <-> 60000, timeago.js - Format dates into stuff like X minutes ago or in X hours, fromnow - More of the same, Note that the built-in Intl.DateTimeFormat has decent support. Generic Utilities Something you'd find in lodash or ramda, but smaller. Most are pretty similar and very small, with minor differences in package structure (single / package-per-helper) and tree shaking vs direct helper import. remeda - 90 tree-shakable helpers (list). rambda - 187 tree-shakable helpers (list). just - 82 helpers in separate packages (list). @fxts/core - 96 tree-shakable helpers. Lazy evaluation support. Honorable mention: underscore, contains many sub-1 kB helpers. It does not tree-shake as well as the libraries above due to codebase structure. Note: lodash itself is not tree-shakable, but has made many attempts at modulaity with lodash.method packages, imports from lodash/method, and lodash-es, none of which work well in practice. Also note that much of the original lodash functionality comes built-in with modern ES. Prefer native versions over libraries as your browser target allows. Validation To check if an object matches an expected schema, you'd often use zod, yup, joi or ajv. But 90% of the time you can get what you need in under 2 kB. Note: I compare a base validation subset (core + object / array + string / number / boolean) under tree-shaking to avoid punishing libs that have more features. v8n - zod-style API with fine-grained checks: v8n().string().minLength(5).first("H").last("o"). No tree shaking, banditypes - The smallest validation library: superstruct - The most popular modular validation library with good tree-shaking, valibot - Another modular validation library, deep-waters - Composable functional validators, . Unique ID Generation Unique ID generation does not take a lot of code, but it's not someting I'd want to write myself. Limit is 500 bytes. Also note that the native crypto.randomUUID has OK support. @lukeed/uuid - Real UUIDs, nanoid - Random IDs with larger alphabet, uid - More of the same, hexoid - Hexadecimal IDs, Colors Color manipulation is rare in pure UI development, but very helpful for data visualization, and uses freaky math. Don't fry your brain, take these: colord - Manipulate colors and convert between spaces, . Extra features come as plugins, 150b to 1.5 kB each. colr - More of the same, polychrome - More of the same, randomcolor - Attractive random colors with configuration. Touch Gestures Touch gestures like swipe, drag, pinch or doubletap are a staple of mobile UX, but recognizing a series of touchmove / pointer events as a gesture is tricky, and testing is painful. Here are two libraries that do the heavy lifting for you: alloyfinger - Pan, swipe, tap, doubletap, longpress, and pinch / rotate. My personal favorite. . tinygesture - Configurable pan, swipe, tap, doubletap, longpress. . Even if you want to detect gestures yourself, juggling mouse, touch and pointer events is hard enough, and browser inconsistencies don't help. Here are two more libraries to assist with that: pointer-tracker - Unified interface for mouse, touch and pointer events, detect-it - Detect present and primary input method (touch / mouse) and supported events, Honorable mentions: any-touch attempts a modular approach to gesture detection, but the core is around 2 kB without any gesture recognizers. rc-gesture, used in ant design system, could be the only react component on the list, but babel-runtime / corejs polyfills hard-wired into the build push the ~2.5 kB size to over 10 kB. Text Search Text search is important for client-side filtering and autosuggests. Naive option.includes(search) has no sensible order on the results, and ignoring word boundaries gives unexpected matches like spa -> newSPAper. First, here are some libraries that prioritize word matches: js-search - Feature-rich and customizable: multi-field indices, stop words, custom stemmers and tokenizers. ndx - Similar to js-search, differs in ranking and is less strict for multi-word queries (compare). Supports field weights. wade - Also similar, (compare) libsearch - Index-free search (slower, but easier to use) with sane ordering One way to find sensible inexact matches is stemming — converting words to a root form. Walked will match walking, etc. Here are a few Porter stemmers for English language: stemmer - porter-stemmer - For non-English words, I only have honorable mentions: snowball-js is 17 kB with 15 languages, lunr-languages supports 30 languages but only works with lunr, the most promising one is natural but it depends on Node.js. Fuzzy search Fuzzy search is another take on inexact matching — the words can be modified. First, we have libraries that only allow insertion: spacecat -> SPACECrAfT. Not perfect for general-purpose text search, but great for filename, command, or URL lookups. fuzzy - Index-free, can highlight matches. fuzzy-search - With stateful index. fzy.js - Matches one string at a time, tree-shakeable scores and match highlighting. total, or ~150 bytes for hasMatch only. fuzzysearch - One string at a time, does not compute score / rank. liquidmetal - Quicksilver algorithm, prioritizes matches at start of word for command abbreviations (e.g. gp -> git push). One string at a time. quick-score - Another quicksilver-based lib, tweaked for long strings. Built-in list filtering and sorting, or 1.2 kB for single-string scoring. Finally, one library is specifically built for spellchecking: fuzzyset - Find misspellings, e.g. missipissi -> Missisipi, Commercial usage costs $42. Contributing Suggestions welcome! See contributing.md, or drop an issue. Footnotes See WIP for possibly awesome libraries I have found, but not yet analyzed deeply, and incubate for awesome libraries that don't meet popularity criteria yet. Collected and reviewed by Vladimir Klepov in 2023. About 🤏 A collection of tiny JS libraries (under 2 kB) to put your bundle on a diet Topics javascript awesome typescript tiny awesome-list Resources Readme License CC0-1.0 license Activity Stars 724 stars Watchers 15 watching Forks 13 forks Report repository Contributors 4 Languages JavaScript 100.0% Footer © 2025 GitHub, Inc. Footer navigation Terms Privacy Security Status Docs Contact Manage cookies Do not share my personal information You can’t perform that action at this time.