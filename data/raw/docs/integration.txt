GitHub - stn1slv/awesome-integration: A curated list of awesome system integration software and resources. Skip to content Navigation Menu Toggle navigation Sign in Product GitHub Copilot Write better code with AI GitHub Advanced Security Find and fix vulnerabilities Actions Automate any workflow Codespaces Instant dev environments Issues Plan and track work Code Review Manage code changes Discussions Collaborate outside of code Code Search Find more, search less Explore All features Documentation GitHub Skills Blog Solutions By company size Enterprises Small and medium teams Startups Nonprofits By use case DevSecOps DevOps CI/CD View all use cases By industry Healthcare Financial services Manufacturing Government View all industries View all solutions Resources Topics AI DevOps Security Software Development View all Explore Learning Pathways Events & Webinars Ebooks & Whitepapers Customer Stories Partners Executive Insights Open Source GitHub Sponsors Fund open source developers The ReadME Project GitHub community articles Repositories Topics Trending Collections Enterprise Enterprise platform AI-powered developer platform Available add-ons GitHub Advanced Security Enterprise-grade security features Copilot for business Enterprise-grade AI features Premium Support Enterprise-grade 24/7 support Pricing Search or jump to... Search code, repositories, users, issues, pull requests... Search Clear Search syntax tips Provide feedback We read every piece of feedback, and take your input very seriously. Include my email address so I can be contacted Cancel Submit feedback Saved searches Use saved searches to filter your results more quickly Name Query To see all available qualifiers, see our documentation. Cancel Create saved search Sign in Sign up Reseting focus You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. Dismiss alert stn1slv / awesome-integration Public Notifications You must be signed in to change notification settings Fork 55 Star 433 A curated list of awesome system integration software and resources. License CC0-1.0 license 433 stars 55 forks Branches Tags Activity Star Notifications You must be signed in to change notification settings Code Issues 0 Pull requests 0 Actions Projects 0 Security Insights Additional navigation options Code Issues Pull requests Actions Projects Security Insights stn1slv/awesome-integration mainBranchesTagsGo to fileCodeFolders and filesNameNameLast commit messageLast commit dateLatest commit History370 Commits.github/workflows.github/workflows .gitattributes.gitattributes CONTRIBUTING.mdCONTRIBUTING.md LICENSELICENSE README.mdREADME.md View all filesRepository files navigationREADMECC0-1.0 licenseAwesome Integration A curated list of awesome system integration software, patterns and resources. System integration is the process of linking together different IT systems (components) to functionally cooperate as a whole. Contents Projects API Management API Design API Documentation API Gateway API Testing BRE BPM Data Mapping Solution ESB ETL Integration Frameworks iPaaS MaaS Managed File Transfer Master Data Management Messaging RPA Self-Service Integration Workflow engine Integration Patterns Enterprise Integration Patterns Integration Architecture Patterns Microservice API Patterns SOA Patterns Resources API Specification Articles Certifications Connectors Data Formats Integration Styles Market Analysis Protocols Standard APIs Structure and Validation Projects API Management API Management solutions offer a comprehensive approach to handling the entire API lifecycle. They enable developers to create, publish, secure, and monitor APIs, ensuring efficient and reliable communication between systems. With features such as authentication, rate limiting, and analytics, these tools provide centralized control and enhanced security, making it easier to manage and scale APIs across different platforms and environments. Akana API Management Platform - Provides comprehensive lifecycle management, enabling rapid digital transformation and robust compliance across multi-cloud environments. Amazon API Management - Leverages AWS scalability and security to efficiently create, monitor, and manage APIs. Anypoint Platform - Combines API design, integration, and management into one unified platform, streamlining connectivity and development. Amplify API Management Platform - Offers an open, agile approach to API management with robust integration and flexible deployment options. Apigee - Delivers powerful analytics, security, and scalability for enterprise-grade API management from Google. Azure API Management - A hybrid, multicloud solution that simplifies API lifecycle management with comprehensive security and analytics. Boomi Cloud API Management - A cloud-native platform enabling seamless API deployment and centralized management with strong integration capabilities. DigitMarket API Manager - Transforms APIs into strategic business tools through end-to-end lifecycle management and enhanced operational insights. Gravitee.io API Management (⭐237) - A lightweight, open-source platform offering flexible API governance, robust security, and straightforward configuration. IBM API Connect - Provides a scalable, secure, and intuitive environment for creating, managing, and monetizing APIs across clouds. IBM webMethods API Management - Offers a comprehensive suite for API lifecycle management that seamlessly integrates on-premises and cloud systems. Kong Enterprise - A cloud-native, enterprise-grade solution that enhances API connectivity, microservices orchestration, and security via a rich plugin architecture. Layer7 API Management - Ensures secure and efficient API development with continuous lifecycle management and advanced integration features. Red Hat 3scale API Management - Simplifies API monetization and governance with a cloud-native approach and powerful scaling capabilities. Sensedia API Management - Provides a full-lifecycle API solution with advanced security, performance monitoring, and streamlined integration. Tyk API Management - Delivers high-performance, open-source API management focused on flexibility, robust security, and scalability. WSO2 API Manager (⭐884) - A fully open-source API platform offering robust governance, flexible deployment, and community-driven innovation. Zuplo API Management - A developer-centric, lightweight platform featuring GitOps integration, rapid edge deployment, extensive OpenAPI support, and seamless monetization. ⬆ back to top API Design API design, documentation, and life-cycle automation tools streamline the process of creating, maintaining, and evolving APIs. These tools offer efficient means to design consistent and scalable APIs, generate comprehensive documentation, and automate various stages of the API life-cycle, enhancing developer experience and promoting API adoption. Dredd (⭐4.2k) - Validate API description docs against backend implementation using this language-agnostic CLI tool. OpenAPI-GUI (⭐1.4k) - Create and validate OpenAPI specs with ease using this intuitive graphical user interface. OpenAPI Diff (⭐900) - Compare OpenAPI specs with version control and visualize the differences in HTML or Markdown format. OpenAPI Generator (⭐23k) - Automate the creation of API client libraries, server stubs, documentation and config files with this powerful OpenAPI Spec tool. OpenAPI Style Validator (⭐214) - Ensure that your OpenAPI specs meet your organization's standards with this flexible and customizable style validator. Spectral (⭐2.6k) - Detect and fix errors in your JSON/YAML files using this linter tool that supports OpenAPI 3.0 & 2.0 and AsyncAPI. Swagger Editor (⭐9k) - Create, describe, and document your API with ease using this open source editor built specifically for OpenAPI-based APIs. Zally (⭐922) - Ensure the quality of your OpenAPI specs with this linter tool that provides extensive analysis and feedback. ⬆ back to top API Documentation Explore a collection of tools and platforms designed to create, maintain, and present clear, concise, and user-friendly documentation for APIs. These resources facilitate seamless collaboration between developers and enable effective communication of API functionalities and specifications. DapperDox (⭐415) - Generates elegant, interactive API documentation from OpenAPI/Swagger specs with easy customization and automated updates. OpenAPI Explorer (⭐324) - Creates intuitive, interactive user interfaces from OpenAPI specs, simplifying API exploration and testing. RapiDoc (⭐1.7k) - Produces highly customizable, interactive API documentation with responsive design and rich configuration options. Redoc (⭐24k) - Delivers clean, modern documentation with advanced theming, multi-language support, and seamless integration. Slate (⭐36k) - Converts markdown into stylish, static API documentation with intuitive navigation and clear code examples. Stoplight Elements (⭐1.9k) - Provides modular, attractive UI components for building comprehensive API reference and tutorial documentation. SwaggerHub - An integrated API design and documentation hub that enhances team collaboration, version control, and automated testing. Swagger UI (⭐27k) - Offers an interactive, in-browser tool for visualizing and testing APIs directly from OpenAPI specifications. SpectaQL (⭐1.1k) - Generates static, customizable documentation for GraphQL schemas, making complex API structures easy to understand. Zudoku (⭐162) - A customizable framework built on OpenAPI, focused on delivering exceptional developer experiences through quality documentation. ⬆ back to top API Gateway API Gateways act as intermediaries between client applications and backend services, enabling key features such as request routing, authentication, rate limiting, and caching. They simplify the process of managing, securing, and monitoring APIs by providing a unified entry point for various services. Apinto (⭐1.5k) - A Golang-based gateway that offers dynamic routing, multi-tenancy, and robust API access control for modern architectures. Ambassador Edge Stack - A Kubernetes-native API gateway designed for high-scale environments with flexible routing and advanced security features. Apache APISIX (⭐14k) - A high-performance, dynamic gateway featuring real-time traffic management and powerful plugin integrations. Apache ShenYu (⭐8.5k) - A Java-native gateway excelling in protocol conversion, service proxying, and comprehensive API governance. Gloo Edge (⭐81) - An Envoy Proxy–based gateway offering advanced traffic control, enhanced security, and observability for microservices ecosystems. Kong API Gateway (⭐40k) - A scalable, cloud-native gateway that simplifies API management through extensive plugin support and seamless microservices integration. KrakenD API Gateway (⭐2.1k) - An ultra-high performance gateway with efficient middleware configuration, robust security, and seamless scaling. Ocelot (⭐8.5k) - A .NET-based gateway offering intuitive routing and easy integration for lightweight API management. Spring Cloud Gateway (⭐4.6k) - Leverages the Spring ecosystem to deliver robust routing, filtering, and security for microservices. Traefik (⭐54k) - A dynamic, cloud-native reverse proxy designed for modern container environments with auto-discovery and load balancing. Tyk API Gateway (⭐10k) - An enterprise-grade, open-source gateway supporting REST, GraphQL, TCP, and gRPC with advanced rate limiting and analytics. ⬆ back to top API Testing The API testing tools section provides a list of software tools and frameworks that developers can use to test REST APIs and message brokers. This section includes GUI clients for testing REST APIs and message brokers, mocking tools for simulating API responses, as well as various testing tools and frameworks to automate testing processes. API clients Advanced REST Client (⭐1.4k) - A robust open-source API client for testing and debugging RESTful services with an intuitive interface. Bruno (⭐32k) - A fast, offline API client designed for git-friendly workflows and seamless testing. curl (⭐37k) - A versatile command-line tool for data transfer across multiple protocols, essential for quick API testing. curlie (⭐3.1k) - A modern, user-friendly frontend to curl that combines simplicity with powerful performance. HTTPie (⭐35k) - An intuitive CLI HTTP client that simplifies crafting API requests and inspecting responses. Hoppscotch (⭐70k) - A lightweight, web-based API development tool offering real-time testing with an intuitive interface. Insomnia (⭐36k) - A cross-platform client that streamlines API debugging and testing for both REST and GraphQL services. posting (⭐8.6k) - A modern, terminal-based API client designed for efficient and seamless API interactions. Postman - The industry-standard tool for API development and testing, featuring automation, mock servers, and collaborative documentation. resty (⭐2.6k) - A Lua-based HTTP client framework providing an interactive shell for streamlined REST service testing. SoapUI (⭐1.6k) - A comprehensive open-source solution for testing both SOAP and REST web services with extensive automation features. MQ clients JMSToolBox (⭐212) - A universal JMS client offering broad compatibility and streamlined messaging testing across various brokers. kcat (⭐5.5k) - A lightweight command-line tool for Apache Kafka, providing efficient message production and consumption. MQTT Explorer (⭐3.3k) - A detailed MQTT client delivering structured topic visualization and intuitive debugging. Offset Explorer - A comprehensive GUI for managing Apache Kafka clusters with user-friendly monitoring and administration tools. Service Bus Explorer (⭐2k) - An advanced GUI for Azure Service Bus that enables in-depth testing and seamless management of topics, queues, and subscriptions. Mocking tools Hoverfly (⭐2.4k) - A lightweight API simulation tool that enables rapid HTTP(S) service virtualization for efficient testing. Imposter (⭐386) - A flexible mock server supporting REST, OpenAPI, SOAP, and more to simulate diverse API behaviors. Microcks (⭐1.5k) - A Kubernetes-native tool for API mocking and testing that supports AsyncAPI, OpenAPI, and Postman Collections. Mockable - An easy-to-configure service for creating custom HTTP responses, ideal for rapid prototyping and testing. Mockbin (⭐105) - A simple endpoint generator for testing HTTP requests with real-time logging and feedback. Mockoon (⭐7k) - A user-friendly tool for designing and running mock REST APIs with real-time simulation and easy setup. MockServer (⭐4.7k) - A powerful solution for mocking any HTTP/HTTPS-based service, streamlining integration testing. Mocky (⭐2k) - A free online service that generates custom HTTP responses for testing API endpoints. Prism (⭐4.5k) - An open-source HTTP mock server that replicates API behavior for early testing and validation. WireMock (⭐6.7k) - A robust and flexible API mocking tool delivering reliable, real-time simulation for comprehensive testing. Testing tools and frameworks Apache JMeter (⭐8.6k) - A feature-rich tool for load testing and performance analysis across diverse web applications and services. Gatling (⭐6.6k) - A powerful load testing framework with a developer-friendly DSL that delivers detailed performance metrics. Karate (⭐8.5k) - A unified testing framework that merges API automation, mocking, and performance testing with simple, expressive syntax. Pyresttest (⭐1.1k) - A Python-based testing tool offering easy YAML/JSON-driven REST API testing and microbenchmarking. REST Assured (⭐6.9k) - A Java DSL that simplifies REST API testing with intuitive syntax and seamless integration into CI pipelines. Schemathesis (⭐2.4k) - A Python library for property-based testing of API schemas, ensuring reliability through robust edge-case detection. Taurus (⭐2k) - An open-source automation framework that simplifies continuous testing with intuitive configuration and integration support. ⬆ back to top BRE Business Rules Engines and Business Rules Management Systems (BRMS) are software systems that allow organizations to define, manage, and execute business rules. These rules are used to automate decision-making processes, enforce business policies, and ensure regulatory compliance. A BRMS provides a way for organizations to centrally manage their business rules and make changes to them quickly and easily, without requiring changes to the underlying code. It is a valuable tool for businesses that need to be agile and respond quickly to changing market conditions. Drools (⭐5.9k) - Open-source engine that supports advanced Decision Model and Notation (DMN) with Eclipse IDE integration for efficient rule development. Easy Rules (⭐5k) - Lightweight Java-based rules engine designed for straightforward rule processing and rapid decision automation. FICO Blaze Advisor - Enterprise-grade decision engine that empowers both business and technical users with an intuitive interface for fast rule creation and management. IBM ODM - Scalable decision management system that streamlines rule authoring, testing, and updates while ensuring compliance and agility. NxBRE (⭐132) - Specialized .NET open-source rule engine offering efficient rule processing tailored for Microsoft environments. OpenL Tablets (⭐165) - Flexible open-source decision management system that simplifies defining and executing business rules and decision tables. Progress Corticon - Model-driven BRMS enabling rapid, no-code rule creation that delivers high-performance automated decisions with guaranteed integrity. Red Hat Decision Manager - Enterprise-class decision platform built on Drools, offering advanced DMN support, intuitive UIs, and high availability for large-scale automation. ⬆ back to top BPM BPM solutions are software tools that help businesses streamline and automate their operational processes to improve efficiency and productivity. These solutions typically provide features such as process modeling, workflow management, task automation, and reporting. They can be used to automate a wide range of processes, from simple tasks like data entry to complex workflows involving multiple departments and stakeholders. Appian BPM Suite - Low-code BPM platform that empowers both IT and citizen developers to quickly build process- and case-centric applications. Genpack Cora SeQuence - Agile process orchestration tool that enhances business efficiency by seamlessly integrating and managing workflows. IBM Business Automation Workflow - Integrated platform combining workflow automation and BPM to optimize operational processes and decision-making. Oracle BPM Suite - Comprehensive solution offering robust process modeling, workflow automation, and real-time analytics to drive operational excellence. Pega Platform - Advanced BPM and RPA platform featuring intelligent process automation and workforce analytics to streamline operations. Red Hat Process Automation Manager - Cloud-native platform that enables cross-functional teams to design, deploy, and manage automated business workflows with agility. SAP Process Orchestration - Robust BPM offering that combines process orchestration with application integration for end-to-end operational efficiency. TIBCO BPM Enterprise - Enterprise BPM solution delivering process automation, documentation, and predictive analytics to enhance performance and decision-making. ⬆ back to top Data Mapping Solution Data Mapping tools are used to define and transform data between different systems, applications, and formats. These tools allow for the mapping of data from source to target, allowing for data transformation and integration. This section covers different data mapping solutions that can be used to facilitate data mapping and transformation processes for different use cases. Altova MapForce - Graphical data mapping solution that enables any-to-any conversion, reducing complexity and accelerating integration projects. AtlasMap (⭐202) - Interactive web-based tool that simplifies mapping across Java, XML, CSV, and JSON data sources with an intuitive interface. JOLT (⭐1.6k) - Java-based JSON transformation library that uses a specification-driven approach for effortless JSON-to-JSON conversions. JSLT (⭐653) - Powerful JSON query and transformation language inspired by jq and XPath, designed for rapid and flexible data manipulation. ⬆ back to top ESB Enterprise Service Bus (ESB) solutions facilitate the integration of disparate systems and applications by providing a communication layer that allows them to exchange information. ESBs offer a range of capabilities such as message routing, transformation, protocol conversion, and data mediation. They typically support various messaging patterns and communication protocols and provide a centralized platform for managing and monitoring message traffic. Anypoint Platform - Comprehensive integration solution that leverages robust ESB capabilities to connect and orchestrate disparate systems. Apache ServiceMix - Versatile open-source integration container combining messaging, routing, and service mediation for flexible enterprise connectivity. ArcESB - Flexible integration platform that synchronizes data across applications, streamlines partner connectivity, and enhances data accessibility. IBM App Connect - Robust integration solution that connects diverse applications and protocols, ensuring seamless data flow across the enterprise. IBM webMethods Integration - Comprehensive platform that accelerates application integration and simplifies connectivity across heterogeneous systems. NServiceBus (⭐2.1k) - Developer-friendly, .NET-based service bus that simplifies messaging and orchestrates service integration efficiently. Oracle Service Bus - Powerful ESB solution that virtualizes and manages service interactions to reduce integration complexity. Oracle SOA Suite - Comprehensive SOA platform that orchestrates services into composite applications, driving efficient business process integration. Red Hat Fuse - Cloud-native integration platform that delivers distributed integration capabilities for agile, scalable connectivity. TIBCO BusinessWorks - Enterprise-grade integration platform implementing proven hybrid integration patterns for reliable data exchange. UltraESB - High-performance ESB engineered for extreme throughput with zero-copy proxying and non-blocking IO techniques. WSO2 Enterprise Integrator (⭐382) - API-centric, cloud-native integration platform offering robust, distributed capabilities for modern software architectures. ⬆ back to top ETL ETL (Extract, Transform, Load) and ELT (Extract, Load, Transform) are processes used to integrate and consolidate data from multiple sources. This section covers a range of open source and commercial tools for performing these tasks, including data ingestion, transformation, and loading into data warehouses or other data storage systems. Apache NiFi (⭐5.2k) - Automated data integration tool with a visual interface that seamlessly extracts, transforms, and delivers data across systems. Airbyte (⭐17k) - Flexible, open-source data integration platform that builds ELT pipelines to move data from diverse sources to modern destinations. CloverDX - Enterprise ETL suite offering robust data transformation and workflow orchestration for scalable integration. Hevo - No-code, fully automated data pipeline platform that supports extensive integrations, simplifying complex data workflows. IBM DataStage - Robust platform that cleanses, transforms, and delivers reliable data, empowering businesses with trusted insights. Informatica PowerCenter - Enterprise-class solution that streamlines big data and cloud analytics through comprehensive data integration management. Microsoft SSIS - Proven data integration solution for building scalable ETL processes within enterprise environments using SQL Server. Oracle Data Integrator - Comprehensive platform that addresses batch loads, real-time processes, and SOA-enabled services for end-to-end data management. Pentaho Data Integration (⭐7.9k) - Intuitive, visual ETL tool that simplifies data ingestion, blending, and cleansing across multiple sources without heavy coding. SAS Data Management - Robust solution that transforms, integrates, and secures data to enhance quality and reliability across the enterprise. Stitch - Developer-friendly SaaS ETL service that effortlessly extracts data from numerous sources into data warehouses for streamlined analytics. Talend Data Integration - Versatile platform that unifies disparate data sources into actionable insights to empower informed business decisions. ⬆ back to top Integration Frameworks The Integration frameworks section includes software tools and libraries that help developers implement and manage integration patterns in their applications. These frameworks are based on well-established Enterprise Integration Patterns (EIPs), which provide a standard vocabulary and architecture for designing and implementing integration solutions. The frameworks in this section can help simplify the process of integrating different systems, applications, and data sources by providing pre-built connectors, message routing, and transformation capabilities. Apache Camel (⭐5.7k) - Robust integration framework leveraging Enterprise Integration Patterns to seamlessly connect diverse systems and APIs. Ballerina (⭐3.7k) - Innovative programming language designed for effortless creation and integration of network services and APIs. Frank!Framework (⭐139) - Low-code Java messaging framework that simplifies system connectivity and data integration through configurable XML setups. Spring Integration (⭐1.5k) - Extension of the Spring ecosystem that provides out-of-the-box integration capabilities using proven Enterprise Integration Patterns. ⬆ back to top iPaaS Integration Platform as a Service (iPaaS) is a cloud-based platform that enables businesses to integrate different systems, applications, and data sources with ease. It provides a unified platform for managing data flows between various systems, simplifying the process of integrating different systems and automating workflows. iPaaS tools typically provide a visual interface for designing, deploying, and managing integrations, as well as pre-built connectors and APIs for integrating with popular systems and services. Anypoint Platform - Combines API management and integration into one platform, enabling seamless connectivity across diverse applications. Boomi AtomSphere - Cloud-native, intelligent platform that connects systems effortlessly while automating integration processes. Celigo Integration Platform - User-friendly iPaaS with prebuilt templates for rapid SaaS-to-SaaS integrations and intuitive drag-and-drop design. Jitterbit Harmony - Comprehensive integration solution offering prebuilt workflows and automation templates to accelerate business processes. IBM Cloud Integration - Next-generation platform leveraging AI to streamline integration, increase scalability, and speed up deployment. IBM webMethods - All-in-one integration platform that unifies applications, simplifies processes, and boosts overall efficiency. Informatica Intelligent Cloud Services - Suite of cloud data management tools that accelerates productivity and simplifies application and data integration. OpenText Alloy - Enterprise data management solution that transforms basic integration into actionable insights and smarter decision-making. Oracle Integration Cloud Service - Robust platform with prebuilt connectivity for both SaaS and on-premises apps, streamlining integration processes. SAP Integration Suite - Cloud-native solution offering prebuilt adapters, API management, and event brokering for end-to-end connectivity. SnapLogic Intelligent Integration Platform - AI-driven platform that connects applications and data rapidly, ensuring efficient and scalable integrations. TIBCO Cloud Integration - Flexible, API-led and event-driven platform that empowers you to integrate virtually any system quickly. Tray.io - Low-code automation platform with a drag-and-drop interface, making it simple to build scalable integrations and workflows. Workato - Unified integration and workflow automation solution that simplifies complex processes and enhances operational efficiency. ⬆ back to top MaaS Cloud Messaging as a Service (MaaS) refers to cloud-based messaging platforms that enable reliable, secure, and scalable communication between distributed applications and services. These platforms provide various messaging patterns such as publish-subscribe, request-reply, and streaming. They also offer features such as message routing, filtering, transformation, and persistence, and support various protocols and APIs for integration with different systems. Amazon MQ - Fully managed message broker supporting Apache ActiveMQ and RabbitMQ, ensuring reliable and secure messaging. Amazon MSK - Managed Apache Kafka service that simplifies cluster setup, scaling, and real-time data streaming. Amazon SQS - Reliable, fully managed queuing service to decouple microservices and scale distributed applications seamlessly. Amazon SNS - Managed pub/sub messaging service that flexibly notifies subscribers and supports various delivery protocols. Alibaba Cloud Message Queue for Apache Kafka - High-throughput Kafka service with seamless Alibaba Cloud integration for real-time data processing. Alibaba Cloud Message Queue for RabbitMQ - Scalable RabbitMQ solution offering low latency and high throughput for distributed messaging. Alibaba Cloud Message Service - Distributed messaging service that ensures reliable data transfer between decoupled systems. AlibabaMQ for Apache RocketMQ - Robust message queue service supporting asynchronous communication with high availability and durability. Anypoint MQ - Enterprise-class messaging service integrated with Anypoint Platform for flexible and reliable message orchestration. Azure Service Bus - Cloud messaging solution that supports multiple patterns and protocols for robust enterprise integration. CloudAMQP - Managed RabbitMQ service featuring an intuitive web console, advanced analytics, and seamless scalability. Confluent Cloud - Fully managed Kafka service offering enterprise features like schema registry, connectors, and governance. Google Cloud Managed Service for Apache Kafka - Simplifies Kafka deployment and management on Google Cloud for real-time streaming applications. Google Cloud Pub/Sub - High-throughput messaging service that supports event-driven architectures with flexible delivery models. Huawei Cloud Distributed Message Service - Fully managed messaging service that ensures secure, scalable, and reliable communication between applications. Huawei Cloud Distributed Message Service for Kafka - Managed Kafka solution that simplifies scaling and management while delivering high performance and security. IBM MQ on Cloud - Enterprise messaging service that offers secure, reliable data transfer across applications in a cloud environment. IronMQ - Elastic, cloud-native message queue designed for scalable and reliable processing of high-volume messages. Oracle Cloud Streaming - Serverless, real-time event streaming platform with Apache Kafka compatibility for efficient data processing. Solace PubSub+ Cloud - Integrated event streaming platform providing full visibility and control over your data pipelines. Yandex Message Queue - Cloud messaging service compatible with Amazon SQS API for easy integration with existing systems. Yandex Managed Service for Apache Kafka - Fully managed Kafka service with automated scaling, monitoring, and maintenance for hassle-free streaming. ⬆ back to top Managed File Transfer Managed File Transfer (MFT) solutions provide secure and reliable file transfer capabilities that help organizations meet regulatory compliance requirements, improve operational efficiency, and reduce the risk of data breaches. MFT software typically includes features such as encryption, digital signatures, user access controls, and detailed audit logs to ensure that data is transmitted securely and can be tracked throughout the transfer process. ArcESB Managed File Transfer - Enterprise-grade MFT solution with an intuitive interface and powerful automation for streamlined file exchanges. Axway Managed File Transfer - Robust platform offering advanced security and efficient, reliable data transfer across enterprise systems. GoAnywhere MFT - Comprehensive solution delivering centralized, secure file transfers with automation and complete audit logging. GlobalSCAPE EFT - Hardened file transfer server that ensures end-to-end encryption, automation, and compliance for mission-critical data. IBM Sterling Secure File Transfer - Scalable and high-performance MFT platform designed for secure, fast, and reliable file exchange. IBM webMethods MFT - Integrated managed file transfer solution that supports flexible deployment across hybrid environments. Oracle Managed File Transfer - Comprehensive platform that simplifies secure file exchange and management for enterprise operations. Progress MOVEit - Secure, automated file transfer solution with guaranteed delivery, encryption, and compliance tools for regulated industries. TIBCO Managed File Transfer - Centralized MFT platform with robust automation and security features designed to support diverse file transfer scenarios. Titan MFT Server - Enterprise-level MFT server offering high availability, failover capabilities, and efficient large-scale file automation. ⬆ back to top Master Data Management Master Data Management solutions help organizations create a single, authoritative source of accurate and consistent data across different systems, applications, and departments. These tools provide capabilities for data profiling, cleansing, enrichment, and governance, enabling organizations to improve data quality, reduce errors, and increase operational efficiency. IBM InfoSphere Master Data Management - Comprehensive platform that centralizes data governance, ensuring consistency and accuracy across your enterprise. Informatica Multidomain MDM - Integrated solution for managing and governing master data across all domains, enhancing overall data quality. Oracle Enterprise Data Management - Robust tool that centralizes master data to support faster, more effective decision-making and operational agility. Reltio - Cloud-native, multi-domain MDM platform combining data quality, governance, and real-time analytics for a 360° view. SAP Master Data Governance - Centralized solution that consolidates and governs master data to ensure consistency and high quality. SAS MDM - Unified platform that integrates data from diverse sources into accurate master records for improved efficiency. Stibo MDM - Proven multi-domain MDM solution focusing on data transparency and governance to provide a single source of truth. Teradata MDM - Establishes a consistent analytical foundation by maintaining accurate reference data for enhanced ROI. TIBCO EBX - Comprehensive platform for governing and managing shared data assets, ensuring consistency and enabling smarter decisions. ⬆ back to top Messaging Message brokers are a type of middleware that allows communication between different applications or systems by facilitating the exchange of messages. They can handle different messaging patterns, such as point-to-point, publish-subscribe, and request-reply, and provide features such as message transformation, routing, and filtering. Apache ActiveMQ (⭐2.3k) - Open-source broker that implements JMS, enabling seamless conversion between synchronous and asynchronous messaging. Apache Kafka (⭐29k) - Distributed, high-throughput system designed for real-time data streaming and fault-tolerant processing. Apache Pulsar (⭐14k) - Versatile pub/sub and streaming platform offering scalable, low-latency messaging for modern applications. Apache RocketMQ (⭐21k) - High-performance distributed messaging platform engineered for low latency and high throughput. Apache Qpid (⭐57) - AMQP-compliant messaging tool with multi-language support for enterprise-grade message delivery. BlazingMQ (⭐2.6k) - Distributed message queuing system focused on efficiency and reliability for modern workflow needs. Centrifugo (⭐8.8k) - Scalable real-time messaging server that minimizes delay in delivering events to online users. Eclipse Mosquitto (⭐9.5k) - Lightweight MQTT broker optimized for low-power devices with robust encryption and authentication. EMQX (⭐14k) - High-performance MQTT broker built for IoT and industrial applications, ensuring scalable message delivery. IBM MQ - Enterprise-grade messaging solution providing robust features, high availability, and multi-protocol support. KubeMQ - Kubernetes-native message broker and queue system designed for scalability, high availability, and seamless cloud integration. NATS (⭐16k) - Lightweight, high-performance messaging system ideal for microservices and cloud-native architectures. Oracle AQ - Integrated messaging solution within Oracle databases, offering reliable and efficient message delivery. RabbitMQ (⭐12k) - Popular open-source broker implementing AMQP, known for reliability, clustering, and ease-of-use. Redpanda (⭐10k) - Kafka-compatible streaming platform that eliminates Zookeeper, delivering high performance and low latency. Red Hat AMQ - Enterprise messaging platform based on open-source technologies, offering scalable and reliable message delivery. TIBCO Enterprise Message Service - Standards-based JMS implementation that enables efficient and robust exchange of messages between applications. VerneMQ (⭐3.2k) - High-performance distributed MQTT broker designed for scalable and efficient message delivery in modern environments. ⬆ back to top RPA Robotic Process Automation (RPA) solutions are software tools that automate repetitive, rule-based tasks within business processes. RPA bots can perform tasks such as data entry, data extraction, and data processing with accuracy and speed, freeing up human workers to focus on more complex tasks. Automation Anywhere - Intelligent automation ecosystem that streamlines business processes and reduces errors through advanced RPA capabilities. Blue Prism - No-code platform delivering robust, scalable automation to minimize manual tasks and boost productivity. Tungsten RPA - AI-powered, no-code automation solution that enhances accuracy, efficiency, and compliance across workflows. UiPath - Comprehensive RPA platform that automates routine tasks, enabling scalable digital transformation across enterprises. WorkFusion - Enterprise automation solution that combines RPA with intelligent automation to streamline complex workflows. ⬆ back to top Self-Service Integration Self-service and citizen integrator tools are designed to enable non-technical users to build integrations without the need for extensive programming knowledge. These tools typically feature drag-and-drop interfaces and pre-built connectors for popular applications and services. IFTTT - Easy-to-use platform that connects web services with simple conditional statements, empowering custom workflow creation. Make (Integromat) - Low-code automation tool with a visual interface, advanced data transformation, and modular workflow execution. Microsoft Power Automate - Cloud-based service with an intuitive interface for creating automated workflows that seamlessly integrate diverse apps. n8n (⭐76k) - Open-source workflow automation tool with 400+ connectors, giving you full control over your data and integrations. Oracle Self-Service Integration - Streamlined tool that automates tasks between cloud applications, making integration accessible for non-developers. Zapier - Intuitive platform that connects hundreds of web services to create efficient, code-free automations. ⬆ back to top Workflow engine Software tools that enable the design, execution, and monitoring of complex workflows or business processes. Workflow engines provide a way to automate and streamline business processes, while orchestration engines help to manage the interactions between different systems or services. Activiti (⭐10k) - Lightweight, Java-centric BPMN engine that efficiently executes business workflows with a focus on simplicity. Apache Airflow (⭐39k) - Platform for programmatically creating, scheduling, and monitoring workflows, ideal for managing complex data pipelines. Argo Workflows (⭐15k) - Container-native workflow engine designed for orchestrating parallel jobs in Kubernetes-based, cloud-native environments. Azkaban (⭐4.4k) - Distributed scheduler that simplifies managing job dependencies in large-scale data processing environments. Bonita (⭐165) - Open-source BPMN engine with a designer interface to build and automate complex business processes. Cadence (⭐8.5k) - Fault-tolerant, stateful platform that reliably orchestrates long-running workflows and complex applications. Camunda (⭐4.1k) - Flexible workflow and decision automation platform designed for scalable business process management. Conductor (⭐12k) - Cloud-based orchestration engine that manages microservices workflows, streamlining complex process automation. Elsa Core (⭐6.9k) - .NET Core library that integrates seamlessly into any application to execute and manage workflows. Flowable (⭐8.3k) - Compact, efficient set of open-source engines for automating and scaling enterprise workflows. jBPM (⭐1.6k) - Comprehensive toolkit for automating business processes and decisions with robust workflow management capabilities. Prefect (⭐18k) - Modern, developer-friendly orchestration tool optimized for data pipelines and complex workflows. StackStorm (⭐6.2k) - Robust automation engine that combines sensors, triggers, and workflows to orchestrate complex IT processes. Temporal (⭐13k) - Open-source workflow-as-code platform designed for building reliable, scalable, and fault-tolerant applications. ⬆ back to top Integration Patterns Integration patterns provide standardized solutions for common integration problems within an enterprise. Enterprise Integration Patterns (EIP) provide a common language for describing integration problems and solutions, while Integration Architecture Patterns address high-level concerns of enterprise architects. Service-Oriented Architecture (SOA) patterns provide guidance for designing and implementing service-oriented architectures, ensuring that services are scalable, reusable, and loosely coupled. Enterprise Integration Patterns Patterns from a book by Gregor Hohpe and Bobby Woolf. Aggregator - How do we combine the results of individual, but related messages so that they can be processed as a whole? Canonical Data Model - How can you minimize dependencies when integrating applications that use different data formats? Channel Adapter - How can you connect an application to the messaging system so that it can send and receive messages? Channel Purger - How can you keep 'left-over' messages on a channel from disturbing tests or running systems? Claim Check - How can we reduce the data volume of message sent across the system without sacrificing information content? Command Message - How can messaging be used to invoke a procedure in another application? Competing Consumers - How can a messaging client process multiple messages concurrently? Composed Message Processor - How can you maintain the overall message flow when processing a message consisting of multiple elements, each of which may require different processing? Content Enricher - How do we communicate with another system if the message originator does not have all the required data items available? Content Filter - How do you simplify dealing with a large message, when you are interested only in a few data items? Content-Based Router - How do we handle a situation where the implementation of a single logical function (e.g., inventory check) is spread across multiple physical systems? Control Bus - How can we effectively administer a messaging system that is distributed across multiple platforms and a wide geographic area? Correlation Identifier - How does a requestor that has received a reply know which request this is the reply for? Datatype Channel - How can the application send a data item such that the receiver will know how to process it? Dead Letter Channel - What will the messaging system do with a message it cannot deliver? Detour - How can you route a message through intermediate steps to perform validation, testing or debugging functions? Document Message - How can messaging be used to transfer data between applications? Durable Subscriber - How can a subscriber avoid missing messages while it is not listening for them? Dynamic Router - How can you avoid the dependency of the router on all possible destinations while maintaining its efficiency? Envelope Wrapper - How can existing systems participate in a messaging exchange that places specific requirements on the message format, such as message header fields or encryption? Event Message - How can messaging be used to transmit events from one application to another? Event-Driven Consumer - How can an application automatically consume messages as they become available? Format Indicator - How can a message`s data format be designed to allow for possible future changes? Guaranteed Delivery - How can the sender make sure that a message will be delivered, even if the messaging system fails? Idempotent Receiver - How can a message receiver deal with duplicate messages? Invalid Message Channel - How can a messaging receiver gracefully handle receiving a message that makes no sense? Message - How can two applications connected by a message channel exchange a piece of information? Message Dispatcher - How can multiple consumers on a single channel coordinate their message processing? Message Expiration - How can a sender indicate when a message should be considered stale and thus shouldn`t be processed? Message Translator - How can systems using different data formats communicate with each other using messaging? Message Broker - How can you decouple the destination of a message from the sender and maintain central control over the flow of messages? Message Bus - What is an architecture that enables separate applications to work together, but in a decoupled fashion such that applications can be easily added or removed without affecting the others? Message Channel - How does one application communicate with another using messaging? Message Endpoint - How does an application connect to a messaging channel to send and receive messages? Message Filter - How can a component avoid receiving uninteresting messages? Message History - How can we effectively analyze and debug the flow of messages in a loosely coupled system? Message Router - How can you decouple individual processing steps so that messages can be passed to different filters depending on a set of conditions? Message Sequence - How can messaging transmit an arbitrarily large amount of data? Message Store - How can we report against message information without disturbing the loosely coupled and transient nature of a messaging system? Messaging Bridge - How can multiple messaging systems be connected so that messages available on one are also available on the others? Messaging Gateway - How do you encapsulate access to the messaging system from the rest of the application? Messaging Mapper - How do you move data between domain objects and the messaging infrastructure while keeping the two independent of each other? Normalizer - How do you process messages that are semantically equivalent, but arrive in a different format? Pipes and Filters - How can we perform complex processing on a message while maintaining independence and flexibility? Point-to-Point Channel - How can the caller be sure that exactly one receiver will receive the document or perform the call? Polling Consumer - How can an application consume a message when the application is ready? Process Manager - How do we route a message through multiple processing steps when the required steps may not be known at design-time and may not be sequential? Publish-Subscribe Channel - How can the sender broadcast an event to all interested receivers? Recipient List - How do we route a message to a list of dynamically specified recipients? Request-Reply - When an application sends a message, how can it get a response from the receiver? Resequencer - How can we get a stream of related but out-of-sequence messages back into the correct order? Return Address - How does a replier know where to send the reply? Routing Slip - How do we route a message consecutively through a series of processing steps when the sequence of steps is not known at design-time and may vary for each message? Scatter-Gather - How do you maintain the overall message flow when a message needs to be sent to multiple recipients, each of which may send a reply? Selective Consumer - How can a message consumer select which messages it wishes to receive? Service Activator - How can an application design a service to be invoked both via various messaging technologies and via non-messaging techniques? Smart Proxy - How can you track messages on a service that publishes reply messages to the Return Address specified by the requestor? Splitter - How can we process a message if it contains multiple elements, each of which may have to be processed in a different way? Test Message - What happens, though, if a component is actively processing messages, but garbles outgoing messages due to an internal fault? Transactional Client - How can a client control its transactions with the messaging system? Wire Tap - How do you inspect messages that travel on a point-to-point channel? ⬆ back to top Integration Architecture Patterns Design patterns used to connect systems and applications in an efficient and seamless manner. API-led Connectivity pattern - Use APIs to connect different systems and applications. Anti Corruption Layer Pattern - Add a layer to isolate and transform data between systems. Change Data Capture Pattern - Capture and propagate changes made to a database or data source in real-time. Hybrid API Management pattern - Manage APIs that span both cloud and on-premises environments using a central control plane. Hybrid Integration pattern - Integrate systems and applications that are deployed both on-premises and in the cloud using a combination of integration technologies. ⬆ back to top Microservice API Patterns MAP (Microservice API Patterns) is a set of proven solutions to common problems encountered when designing, implementing, and maintaining message-based APIs. It focuses on the message representations or payloads exchanged during API calls and their impact on the design and runtime qualities of an API. Proper governance of API specifications and implementations is essential for their long-term maintenance. Foundation Frontend Integration - How can client-side end-user interfaces that are physically separated from server-side business logic and data storage be populated and updated with computing results, result sets from searches in data sources, and detailed information about data entities? How can application frontends invoke activities in a backend or upload data to it? Backend Integration - How can distributed applications and their parts, which have been built independently and are deployed separately, exchange data and trigger mutual activity while preserving system-internal conceptual integrity without introducing undesired coupling? Public API - How can an API be made available to an unlimited and/or unknown number of API clients outside the organization that are globally, nationally, and/or regionally distributed? Community API - How can the visibility of and the access to an API be restricted to a closed user group that does not work for a single organizational unit but for multiple legal entities (such as companies, nonprofit/nongovernment organizations, and governments)? Solution-Internal API - How can access to and usage of an API be limited to an application, for instance, components in the same or another logical layer and/or physical tier? API Description - Which knowledge should be shared between an API provider and its clients? How should this knowledge be documented? Responsibility Endpoint Roles Processing Resource - How can an API provider allow its clients to trigger an action in it? Information Holder Resource - How can domain data be exposed in an API, but its implementation still be hidden? How can an API expose data entities so that API clients can access and/or modify these entities concurrently without compromising data integrity and quality? Operation Responsibilities State Creation Operation - How can an API provider allow its clients to report that something has happened that the provider needs to know about, for instance, to trigger instant or later processing? Retrieval Operation - How can information available from a remote party (the API provider, that is) be retrieved to satisfy an information need of an end user or to allow further client-side processing? State Transition Operation - How can a client initiate a processing action that causes the provider-side application state to change? How can API clients and API providers share the responsibilities required to execute and control business processes and their activities? Computation Function - How can a client invoke side-effect-free remote processing on the provider side to have a result calculated from its input? Information Holder Types Operational Data Holder - How can an API support clients that want to create, read, update, and/or delete instances of domain entities that represent operational data: data that is rather short-lived, changes often during daily business operations, and has many outgoing relations? Master Data Holder - How can I design an API that provides access to master data that lives for a long time, does not change frequently, and will be referenced from many clients? Reference Data Holder - How should data that is referenced in many places, lives long, and is immutable for clients be treated in API endpoints? How can such reference data be used in requests to and responses from Processing Resources or Information Holder Resources? Link Lookup Resource - How can message representations refer to other, possibly many and frequently changing, API endpoints and operations without binding the message recipient to the actual addresses of these endpoints? Data Transfer Resource - How can two or more communication participants exchange data without knowing each other, without being available at the same time, and even if the data has already been sent before its recipients became known? Structure Representation Elements Atomic Parameter - How can simple, unstructured data (such as a number, a string, a Boolean value, or a block of binary data) be exchanged between API client and API provider? Atomic Parameter List - How can multiple related Atomic Parameters be combined in a representation element so that each of them stays simple, but their relatedness becomes explicit in the API Description and the runtime message exchanges? Parameter Tree - How can containment relationships be expressed when defining complex representation elements and exchanging such related elements at runtime? Parameter Forest - How can multiple Parameter Trees be exposed as request or response payload of an API operation? Element Stereotypes Data Element - How can domain/application-level information be exchanged between API clients and API providers without exposing provider-internal data definitions in the API? How can API client and API provider be decoupled from a data management point of view? Metadata Element - How can messages be enriched with additional information so that receivers can interpret the message content correctly, without having to hardcode assumptions about the data semantics? Id Element - How can API elements be distinguished from each other at design time and at runtime? When applying domain-driven design, how can elements of the Published Language be identified? Link Element - How can API endpoints and operations be referenced in request and response message payloads so that they can be called remotely? Special Purpose Representations API Key - How can an API provider identify and authenticate clients and their requests? Error Report - How can an API provider inform its clients about communication and processing faults? How can this information be made independent of the underlying communication technologies and platforms (for example, protocol-level headers representing status codes)? Context Representation - How can API consumers and providers exchange context information without relying on any particular remoting protocols? How can identity information and quality properties in a request be made visible to related subsequent ones in conversations? Quality Reference Management Embedded Entity - How can one avoid sending multiple messages when their receivers require insights about multiple related information elements? Linked Information Holder - How can messages be kept small even when an API deals with multiple information elements that reference each other? Data Transfer Parsimony Pagination - How can messages be kept small even when an API deals with multiple information elements that reference each other? Wish List - How can an API client inform the API provider at runtime about the data it is interested in? Wish Template - How can an API client inform the API provider about nested data that it is interested in? How can such preferences be expressed flexibly and dynamically? Conditional Request - How can unnecessary server-side processing and bandwidth usage be avoided when frequently invoking API operations that return rarely changing data? Request Bundle - How can the number of requests and responses be reduced to increase communication efficiency? Quality Management and Governance Pricing Plan - How can the API provider meter API service consumption and charge for it? Rate Limit - How can the API provider prevent API clients from excessive API usage? Service Level Agreement - How can an API client learn about the specific quality-of-service characteristics of an API and its endpoint operations? How can these characteristics, and the consequences of not meeting them, be defined and communicated in a measurable way? Evolution Version Identifier - How can an API provider indicate its current capabilities as well as the existence of possibly incompatible changes to clients in order to prevent malfunctioning of clients due to undiscovered interpretation errors? Semantic Versioning - How can stakeholders compare API versions to detect immediately whether they are compatible? Two In Production - How can a provider gradually update an API without breaking existing clients but also without having to maintain a large number of API versions in production? Aggressive Obsolescence - How can API providers reduce the effort for maintaining an entire API or its parts (such as endpoints, operations, or message representations) with guaranteed service quality levels? Experimental Preview - How can providers make the introduction of a new API, or new API version, less risky for their clients and obtain early adopter feedback without having to freeze the API design prematurely? Limited Lifetime Guarantee - How can a provider let clients know for how long they can rely on the published version of an API? Eternal Lifetime Guarantee - How can a provider support clients that are unable or unwilling to migrate to newer API versions at all? ⬆ back to top SOA Patterns SOA patterns are design solutions that provide guidelines and best practices for developing flexible and reusable service-oriented applications. These patterns address various aspects of service-oriented application design, including service identification, interaction, composition, and granularity. Foundational Inventory Patterns Canonical Protocol - Defines a common communication protocol between services to enable interoperability and decoupling. Canonical Schema - Defines a standard data model and format for exchanging data between services. Domain Inventory - Identifies and categorizes the types of services within a particular domain. Enterprise Inventory - Identifies and categorizes the types of services within a particular domain. Logic Centralization - Centralizes business logic within a service layer to reduce redundancy and promote consistency. Service Layers - Centralizes business logic within a service layer to reduce redundancy and promote consistency. Service Normalization - Centralizes business logic within a service layer to reduce redundancy and promote consistency. Logical Inventory Layer Patterns Entity Abstraction - Abstracts data entities to simplify data access and reduce coupling. Process Abstraction - Abstracts processes to improve reusability and maintainability. Utility Abstraction - Abstracts common utilities to reduce duplication and promote consistency. Micro Task Abstraction - Breaks down tasks into smaller, more granular tasks for easier management. Inventory Centralization Patterns Policy Centralization - Centralizes policies to reduce duplication and improve consistency. Process Centralization - Centralizes processes to improve reusability and maintainability. Rules Centralization - Centralizes business rules to reduce duplication and promote consistency. Schema Centralization - Centralizes data schemas to reduce duplication and improve consistency. Inventory Implementation Patterns Canonical Resources - Defines a standard set of resources for common functionality across services. Cross-Domain Utility Layer - Uses multiple protocols for improved performance and flexibility. Dual Protocols - Defines a common utility layer across multiple domains. Inventory Endpoint - Defines a standard endpoint for accessing inventory resources. Service Grid - Provides a framework for managing and scaling services. State Repository - Stores and manages service state information. Stateful Services - Maintains state information across service invocations. Augmented Protocols - Enhances protocols with additional features. Inventory Governance Patterns Canonical Expression - Defines a standard expression language for inventory data. Canonical Versioning - Defines a standard versioning scheme for inventory resources. Metadata Centralization - Centralizes metadata to reduce duplication and improve consistency. Foundational Service Patterns Agnostic Capability - Abstracts service capabilities for improved flexibility. Agnostic Context - Abstracts service context for improved flexibility. Functional Decomposition - Breaks down services into smaller, more manageable components. Non-Agnostic Context - Breaks down services into smaller, more manageable components. Service Encapsulation - Encapsulates service functionality for improved maintainability. Service Implementation Patterns Partial State Deferral - Encapsulates service functionality for improved maintainability. Partial Validation - Validates only relevant data for improved performance. Redundant Implementation - Implements multiple versions of a service for improved flexibility. Service Data Replication - Replicates data across multiple services for improved performance. Service Façade - Provides a simplified interface to a complex service for improved usability. UI Mediator - Mediates between the user interface and underlying services for improved usability. Reference Data Centralization - Centralizes reference data to reduce duplication and improve consistency. Microservice Deployment - Deploys services as independent, autonomous units for improved scalability and resilience. Containerization - How can an environment be provided with maximum support for services with high-performance recovery and scalability requirements? Service Security Patterns Exception Shielding - Protects against security vulnerabilities through proper handling of exceptions. Message Screening - Screens messages for malicious content. Service Perimeter Guard - Guards the service perimeter to prevent unauthorized access. Trusted Subsystem - Establishes trust between subsystems for improved security. Service Contract Design Patterns Concurrent Contracts - Allows multiple versions of a service contract to coexist simultaneously. Contract Centralization - Centralizes service contracts to improve consistency and reduce duplication. Contract Denormalization - Centralizes service contracts to improve consistency and reduce duplication. Decoupled Contract - Decouples service contracts from their implementation for improved flexibility. Validation Abstraction - Abstracts validation logic to improve reusability and maintainability. Legacy Encapsulation Patterns File Gateway - Provides a gateway to access legacy file-based systems. Legacy Wrapper - Wraps legacy systems to expose them as services. Multi-Channel Endpoint - Provides multiple communication channels to access legacy systems. Service Governance Patterns Compatible Change - Enables changes to a service without breaking existing clients. Decomposed Capability - Breaks down a service capability into smaller, more manageable pieces. Distributed Capability - Breaks down a service capability into smaller, more manageable pieces. Proxy Capability - Provides a proxy to a remote service capability to improve performance and reduce network overhead. Service Decomposition - Breaks down a monolithic service into smaller, more manageable pieces. Service Refactoring - Refactors a service to improve its design and performance. Termination Notification - Notifies clients of a service's termination. Version Identification - Identifies the version of a service. Capability Composition Patterns Capability Composition - Combines multiple service capabilities to create a new capability. Capability Recomposition - Recombines existing service capabilities to create a new capability. Service Messaging Patterns Asynchronous Queuing - Uses a message queue to decouple services and improve scalability and reliability. Event-Driven Messaging - Uses events to trigger service invocations and reduce coupling. Intermediate Routing - Uses intermediate routing nodes to improve performance and flexibility. Messaging Metadata - Uses metadata to describe and manage service messages. Reliable Messaging - Ensures message delivery and reliability in a distributed environment. Service Agent - Acts as a proxy for a remote service to improve performance and reduce network overhead. Service Callback - Uses callbacks to communicate between services. Service Instance Routing - Routes messages based on the service instance to improve performance and scalability. Service Messaging - Describes the communication between services. State Messaging - Uses messages to manage state information in a distributed environment. Composition Implementation Patterns Agnostic Sub-Controller - Separates sub-controllers from the main controller to improve reusability and maintainability. Atomic Service Transaction - Uses transactions to ensure atomicity and consistency across multiple service invocations. Compensating Service Transaction - Reverses the effects of a failed transaction. Composition Autonomy - Enables services to act autonomously within a composition. Service Interaction Security Patterns Brokered Authentication - Authenticates clients through a broker. Data Confidentiality - Ensures data confidentiality in a distributed environment. Data Origin Authentication - Authenticates the origin of a message. Direct Authentication - Authenticates clients directly. Transformation Patterns Data Format Transformation - Transforms data formats to enable interoperability. Data Model Transformation - Transforms data models to enable interoperability. Protocol Bridging - Bridges between different protocols to enable interoperability. REST-inspired Patterns Entity Linking - Links related resources to enable navigation and discovery. Lightweight Endpoint - Provides a lightweight endpoint for resource access. Reusable Contract - Reuses common contracts to improve consistency and reduce duplication. Content Negotiation - Negotiates the content format between clients and servers. Endpoint Redirection - Redirects clients to alternative endpoints. Idempotent Capability - Ensures that the same action can be performed multiple times without changing the system state. ⬆ back to top Resources Some useful specifications, standards, articles and documentation. API Specification API Blueprint (⭐8.6k) - A powerful high-level language for designing and documenting APIs that allows software engineers to easily collaborate and create efficient APIs. AsyncAPI (⭐4.5k) - An essential tool for developing Event-Driven Architectures (EDA) and enables engineers to build a better tooling ecosystem. CloudEvents (⭐5.2k) - A specification for describing event data in common formats to provide interoperability across services, platforms and systems. GraphQL (⭐14k) - A sophisticated query language and runtime for building efficient APIs that empowers engineers to retrieve data from existing systems with ease. JSON:API (⭐7.5k) - A standardized specification for building APIs that simplifies the representation of resources, relationships, and metadata, making it easier for software engineers to create efficient APIs. OpenAPI (ex.Swagger) (⭐29k) - A language-agnostic specification for creating RESTful APIs that enables both humans and machines to understand the capabilities of a service without the need for source code or documentation. RAML (⭐3.8k) - A RESTful API Modeling Language that allows software engineers to design and create efficient APIs by modeling resources, endpoints, and interactions. Standard Webhooks (⭐1.3k) - Open source tools and guidelines for sending webhooks easily, securely, and reliably. WSDL - A powerful XML-based interface description language for SOAP-based services that enables software engineers to describe the functionality of a web service and automate the creation of client code. ⬆ back to top Articles API-Security-Checklist (⭐22k) - Best practices about REST API security. Architectural Styles and the Design of Network-based Software Architectures - Roy Fielding's dissertation defining REST. Enterprise Integration Using REST - Discusses the constraints and flexibility that you have with nonpublic APIs, and lessons learned from doing large scale RESTful integration across multiple teams. Richardson Maturity Model - Explained by Martin Fowler, originally presented by Leonard Richardson. Web API Design: Crafting interfaces that developers love - Creating Web APIs that are consistent, intuitive, and user-friendly for developers. ⬆ back to top Certifications API Academy API Designer - Validate your understanding of API design basics and best practices. API Product Manager - Demonstrate your proficiency in managing APIs as products. API Security Architect - Validate your expertise in securing APIs using modern architectures. APIsec University API Documentation Best Practices - The 2-hour course covers everything you need to know to create, automate, and publish API documentation your developers, partners and users will love. You wll also learn why API documentation is the foundation for strong governance, effective API security, and achieving your API business goals. API Penetration Testing - The API Penetration Testing course covers all the key topics to become an APIsec professional. This hands-on course includes over 12 hours of live instruction and provides detailed labs on API hacking techniques and how to uncover vulnerabilities. API Security for PCI Compliance - This 60-minute course examines the new PCI DSS 4.0 requirements and details the API security obligations for compliance. DSS 4.0 introduces API security concerns for the time ever - enroll to understand what the implications are for your organization. API Security Fundamentals - The 90-minute course covers the core threats to APIs and how to prevent breaches. Learn the OWASP API Security Top 10, examine real-world API attacks, and understand the 3 Pillars of API Security. Certified API Security Analyst - The CASA exam is designed to test your expertise in API security threats, risks, and best practices. Students are expected to have completed the OWASP API Security and Beyond! course before attempting to earn the CASA certification. OWASP API Security Top 10 - The 90-minute course provides a deep-dive into the 2023 edition of the OWASP API Security Top 10 - and covers key concepts that didn't make it into the Top 10. Securing API Servers - Learn key concepts for keeping API servers secure - from CORS to error handling to rate limiting and more. Apollo Apollo Graph Developer - Associate Certification - Developers who obtain this certification possess a solid foundational knowledge of GraphQL and the Apollo tool suite to design a schema, run an Apollo Server 4, and perform queries with Apollo Client 3 on the frontend. Apollo Graph Developer - Professional Certification - Developers who obtain this certification demonstrate strong familiarity with Apollo Federation concepts. They can apply those concepts to build a federated supergraph or move an existing monolithic graph to federation. Boomi Associate Administrator Certification - Validates an individual's foundational knowledge and skills in managing and administering the Boomi platform, focusing on platform monitoring, troubleshooting, and security. Associate Developer Certification - Demonstrates a candidate's basic understanding of building and deploying integration processes using the Boomi platform, including design patterns, deployment, and error handling. Associate EDI for X12 Certification - Validates an individual's proficiency in using Boomi to design, develop, and manage Electronic Data Interchange (EDI) integrations with the X12 standard, covering essential concepts like EDI document structure and trading partner management. Associate Flow Essentials Certification - Showcases a candidate's knowledge of creating and managing business applications using Boomi Flow, with emphasis on workflow design, user interfaces, and data integration. Associate Master Data Hub Certification - Highlights a candidate's understanding of using the Boomi Master Data Hub to ensure data quality and consistency across systems, focusing on data modeling, governance, and synchronization. Development and Application Architecture Certification - Confirms an individual's expertise in designing and implementing complex integration solutions and application architectures on the Boomi platform, including best practices and performance optimization. Professional API Design Certification - Demonstrates a candidate's ability to design, develop, and manage APIs using Boomi, including RESTful API principles, API security, and versioning. Professional API Management Certification - Validates an individual's expertise in managing the full lifecycle of APIs using the Boomi platform, including API deployment, monitoring, and analytics. Professional Developer Certification - Recognizes a candidate's in-depth knowledge and skills in developing, deploying, and managing integration processes using Boomi, with emphasis on advanced data transformation and error handling techniques. Professional Flow Developer Certification - Showcases an individual's advanced capabilities in designing, developing, and managing business applications using Boomi Flow, including complex workflow design, custom UI components, and integration with external systems. Professional Linux Operational Administrator Certification - Confirms a candidate's proficiency in managing and administering Boomi on Linux systems, covering topics such as system installation, configuration, security, and performance optimization. Professional Windows Operational Administrator Certification - Validates an individual's expertise in managing and administering Boomi on Windows systems, focusing on system installation, configuration, security, and performance optimization. IBM IBM Certified Solution Developer – App Connect Enterprise V11 - Validate your intermediate-level knowledge and experience to develop, deploy, tune, and support platform-independent message flow applications using IBM App Connect V11.0. IBM Certified Solution Implementer – API Connect v10.0.3 - Demonstrate your intermediate-level knowledge and skills to develop, publish, configure, and manage APIs using IBM API Connect v10.0.3. Gravitee Event-native API Management Foundations - Basics of Event-native API Management. Event-native API Management Professional - Focuses on some more advanced API Management concepts, plus foundational knowledge around how to use Gravitee API Management. Kong Kong Gateway Certified Associate - Validate your entry-level knowledge and skills on Kong Gateway for developers, DevOps, and architects. Mulesoft MuleSoft Certified Developer - Level 1 - Validate your knowledge and skills to design, build, test and debug, deploy, and manage basic APIs and integrations using MuleSoft. MuleSoft Certified Developer - Level 2 - Validate your ability to work on production-ready Mule applications that address and balance critical non-functional requirements including monitoring, performance, maintainability, reliability, and security. MuleSoft Certified Integration Architect - Level 1 - Validate your knowledge and skills to translate functional and non-functional requirements into integration interfaces and implementations. MuleSoft Certified Platform Architect - Level 1 - Validate your knowledge and skills to direct the emergence of an effective application network out of individual integration solutions following API-led connectivity across an organization using Anypoint Platform. Oracle Oracle Business Process Management Suite 12c Certified Implementation Specialist - Validate your expertise in implementing Oracle BPM Suite 12c solution. Oracle Cloud Platform Application Integration 2022 Certified Professional - Validate your understanding of Oracle Application Integration to implement these Cloud services. Oracle Data Integrator 12c Certified Implementation Specialist - Validate your expertise in selling or implementing Oracle Data Integration 12c solutions. Oracle SOA Suite 12c Certified Implementation Specialist - Validate your expertise in implementing solutions based on Oracle SOA Suite 12c. Red Hat Red Hat Certified Specialist in API Management - Validates the ability to create and maintain enterprise APIs using the Red Hat 3scale API Management platform. Red Hat Certified Specialist in Business Rules - Checks the knowledge, skills, and abilities needed to perform tasks involving the implementation and management of business logic using the Red Hat JBoss BRMS. Red Hat Certified Specialist in Cloud-native Integration - Validates the ability to create and maintain enterprise integration services based on Red Hat Fuse, Camel, and APIs. Red Hat Certified Specialist in Event-Driven Development with Kafka - Validates the ability to develop applications using Apache Kafka and Apache Kafka Streams. SAP SAP Certified Associate - Integration Developer - Validates that the candidate possesses the fundamental and core knowledge required of the SAP Integration Suite profile. SnapLogic SnapLogic Administrator Certification - Assesses your ability to handle administrative tasks for SnapLogic instances. SnapLogic Architect Certification - Evaluates your knowledge of integration reference architectures and key strategies for the SnapLogic platform, covering topics like SnapLogic Architecture, Snaplex Requirements, Pipeline Lifecycle Management, Advanced Data Transformations, API Management, Resumable Pipelines, and Best Practices. SnapLogic Certified Enterprise Automation Professional - An advanced certification covering topics like SnapLogic platform, asset management, workflows, expression language, tasks, pipeline modularization, migration, and user assistance videos for various endpoints. SnapLogic Developer Certification - Testing your expertise in using the SnapLogic SDK, implementing different parts of Snap functionality, and building custom Snaps. SnapLogic Integrator Certification - Focuses on topics such as beginner training, ultra tasks, pipeline migration, and user assistance videos covering various integration endpoints. TIBCO TIBCO BusinessWorks Associate - Checks the understanding of Business Studio and TIBCO Cloud Integration, designing application components (modules, WSDL, REST API), developing integration applications, and testing, deploying, and managing applications. TIBCO BusinessWorks Certified Professional - Validates the ability to design, develop, deploy, monitor, and manage TIBCO BusinessWorks applications of average complexity with minimal supervision. TIBCO BusinessWorks Container Edition Certified Professional - Validates the ability to develop, deploy, and manage TIBCO BusinessWorks Container Edition applications of average complexity with minimal supervision. TIBCO BPM Enterprise Associate - Checks the understanding of TIBCO BPM's features and capabilities, developing and managing business processes, and deploying and testing process applications. TIBCO BPM Enterprise Certified Professional - Validates the ability to design, develop, deploy, and manage business processes using TIBCO BPM Enterprise Suite. TIBCO Cloud Associate Certification - Validates the skills and knowledge required to work with TIBCO Cloud, including its key components and features. TIBCO Cloud API Management Associate - Covers topics such as API definition creation and testing, API key authentication, and using the Developer Portal and I/O docs. TIBCO Cloud API Management Certified Professional - Validates the ability to implement TIBCO Cloud Mesh, OAuth-based security, and manage SOAP services. TIBCO Cloud Integration Associate - Validates the skills and knowledge required to work with TIBCO Cloud Integration, including its Connect, Develop, and Integrate capabilities. TIBCO Cloud Integration - Connect Associate - Checks the usage of Connect capability of TIBCO Cloud Integration, installing On-Premise Agent, creating connections and integration apps, and configuring flows. TIBCO Cloud Integration - Connect Certified Professional - Checks the creation and management of connections, ensuring connection security, and troubleshooting issues related to connections in TIBCO Cloud Integration. TIBCO Cloud Integration Certified Professional - Checks the knowledge about capabilities and benefits, integrating, developing, and connecting applications, creating APIs using the API Modeler and Mock functionality, and more. TIBCO Messaging Associate - Covers topics such as TIBCO Enterprise Message Service (EMS), TIBCO FTL, TIBCO eFTL, as well as other messaging technologies such as Apache Kafka, Apache Pulsar, and Eclipse Mosquitto. TIBCO Messaging Certified Professional - Validates the skills and knowledge required to work with TIBCO Messaging and its components, including TIBCO Enterprise Message Service (EMS), TIBCO FTL, and TIBCO eFTL. Workato Workato Automation Pro I - Fundamentals of business automation processes. Workato Automation Pro II - Advanced and practical approaches to automation. Workato Automation Pro III - In-depth series of badged modules for maximizing Workato's potential. WSO2 WSO2 Certified API Manager Developer - V3 - Assesses your expertise in designing, developing, and publishing APIs using WSO2 API Manager V3, including API lifecycle management, access control, and API documentation. WSO2 Certified API Manager Developer - V4 - Micro Integrator Profile - Validates your expertise in designing, developing, and publishing APIs using the Micro Integrator profile of WSO2 API Manager V4. It covers API lifecycle management, access control, and API documentation within the Micro Integrator context. WSO2 Certified API Manager Expert - V3 - Confirms your advanced skills and knowledge in using WSO2 API Manager V3 for API management, including API creation, publishing, security, policy implementation, and analytics. WSO2 Certified API Manager Expert - V4 - API Management Profile - Demonstrates your proficiency in using WSO2 API Manager V4 for API management tasks, such as creating, publishing, and securing APIs, as well as implementing policies and analytics. WSO2 Certified Enterprise Integrator Developer - V6 - Validates your ability to develop, deploy, and manage integration solutions using WSO2 Enterprise Integrator V6, including knowledge of its components, such as the ESB profile, Message Broker, and Business Process Server. WSO2 Certified Enterprise Integrator Developer - V7 - Micro Integrator - Validates your knowledge and skills in using the Micro Integrator profile of WSO2 Enterprise Integrator V7 to develop, deploy, and manage integration solutions. WSO2 Certified Enterprise Integrator Developer - V7 - Streaming Integrator - Demonstrates your expertise in using the Streaming Integrator profile of WSO2 Enterprise Integrator V7 to develop, deploy, and manage real-time data integration and streaming analytics solutions. WSO2 Certified Enterprise Integrator Expert - V6 - Tests your in-depth knowledge and skills in using WSO2 Enterprise Integrator V6 for complex integration scenarios, including best practices, troubleshooting, and performance tuning. WSO2 Certified Solutions Architect Associate - Assesses your understanding of the fundamental concepts and principles of WSO2 product architecture, as well as your ability to design and implement solutions using WSO2 technologies. ⬆ back to top Connectors JCA - Defines a standard architecture for Jakarta EE application components to connect to Enterprise Information Systems. Formerly Java EE Connector Architecture and J2EE Connector Architecture. Kafka Connect - A tool for scalably and reliably streaming data between Apache Kafka and other systems. ⬆ back to top Data Formats Apache Avro (⭐3k) - Data serialization system that provides compact, fast, and efficient serialization of structured data. It supports schema evolution, allows for efficient data compression, and is designed to work well with big data processing frameworks. BSON - Binary-encoded serialization format for JSON-like documents that is designed to be lightweight and efficient. It supports rich data types and is widely used in NoSQL databases, such as MongoDB. CSV - A simple and widely used data format that stores tabular data in plain text. It is easy to read and write, and can be processed by most programming languages. JSON - A lightweight and easy-to-read data format that is widely used for data exchange. It supports a wide range of data types and is compatible with many programming languages. NDJSON (⭐729) - A standard for delimiting JSON objects in stream protocols. It allows for efficient processing of large JSON datasets and is widely used in big data processing. Protocol Buffers (⭐67k) - A language-neutral and platform-neutral serialization mechanism that is designed to be highly efficient and extensible. It supports rich data types and is widely used in distributed systems, such as gRPC and Apache Kafka. XML - A flexible and widely used markup language that is used for storing and exchanging structured data. It supports rich data types and is compatible with many programming languages. YAML (⭐383) - A human-friendly and easy-to-read data serialization format that is widely used for configuration files and data exchange. It supports rich data types and is compatible with most programming languages. ⬆ back to top Integration Styles File Transfer - Data is exchanged through file exchange between applications. Messaging - Applications exchange messages using a messaging infrastructure. Remote Procedure Invocation - Applications call functions or procedures on a remote server over a network. Shared Database - Multiple applications access and manipulate the same data through a common database. ⬆ back to top Market Analysis API Management Gartner Critical Capabilities for Full Life Cycle API Management Gartner Magic Quadrant for Full Life Cycle API Management The Forrester Wave: API Management Solutions BPM Gartner Critical Capabilities for Intelligent Business Process Management Suites Gartner Magic Quadrant for Intelligent Business Process Management Suites ETL Gartner Critical Capabilities for Data Integration Tools Gartner Magic Quadrant for Data Integration Tools iPaaS Gartner Critical Capabilities for Enterprise Integration Platform as a Service Gartner Magic Quadrant for Enterprise Integration Platform as a Service The Forrester Wave: Enterprise iPaaS RPA Gartner Critical Capabilities for Robotic Process Automation Gartner Magic Quadrant for Robotic Process Automation The Forrester Wave: Robotic Process Automation ⬆ back to top Protocols AMQP 0-9-1 - A message queuing protocol that enables the exchange of messages between applications or systems. AMQP 0-9-1 provides reliability, security, and flexibility to handle complex messaging scenarios. AMQP 1.0 - A widely accepted message queuing protocol that provides reliable, interoperable, and efficient messaging between systems. AMQP 1.0 supports a broad range of messaging scenarios and is ideal for complex enterprise-level applications. CoAP - A specialized application protocol designed for constrained devices in the Internet of Things (IoT) ecosystem. CoAP offers a lightweight, low-overhead communication mechanism to support resource-constrained devices. HTTP - A widely used protocol that facilitates communication between web servers and clients. HTTP enables the transfer of data over the internet, making it possible for web applications to function seamlessly. JSON-RPC - A simple and lightweight remote procedure call protocol that enables communication between systems using JSON data. JSON-RPC offers stateless communication and is suitable for resource-constrained devices. MQTT - A lightweight and efficient publish-subscribe protocol that supports messaging between devices. MQTT enables low-overhead communication and is ideal for IoT and mobile applications. OpenMessaging (⭐290) - A cloud native, vendor-neutral open specification for distributed messaging. SOAP - A messaging protocol that uses XML to enable communication between systems. SOAP supports a wide range of messaging scenarios, including distributed computing and enterprise applications. STOMP - A messaging protocol that offers simple, text-oriented communication between systems. STOMP is ideal for low-latency, high-performance messaging scenarios. ⬆ back to top Standard APIs JDBC - A Java-based API that provides universal data access to relational databases. JDBC offers a consistent and efficient way to access and manipulate data, making it a popular choice among developers. JMS - A messaging API that enables Java applications to send and receive messages. JMS supports reliable messaging and is widely used in enterprise-level applications. ODBC - A widely accepted API that provides a standardized way to access data from various database management systems. ODBC offers a consistent interface to access data, making it easy to develop database applications. OData - An open protocol that enables the creation and consumption of queryable and interoperable REST APIs. OData simplifies the development of REST APIs and offers a standardized way to access data. ⬆ back to top Structure and Validation JSON Schema (⭐4.1k) - A powerful tool for validating the structure of JSON data. JSON Schema enables developers to ensure that JSON data conforms to a specific structure, making it easier to process and manipulate. Schematron - A rule-based validation language that enables developers to define and validate business rules, data reporting, quality control, and other validation scenarios. Schematron offers a flexible way to validate XML documents. XML Schema - A schema language that offers facilities for describing the structure and constraining the contents of XML documents. XML Schema enables developers to ensure that XML data conforms to a specific structure, making it easier to process and manipulate. ⬆ back to top Contributing Your contributions are always welcome! Please take a look at the contribution guidelines first. About A curated list of awesome system integration software and resources. Topics testing api markdown workflow json awesome etl rest-api messaging openapi mulesoft ipaas esb awesome-list bpm api-design mq apim apimanagement Resources Readme License CC0-1.0 license Activity Stars 433 stars Watchers 13 watching Forks 55 forks Report repository Contributors 8 Languages Markdown 100.0% Footer © 2025 GitHub, Inc. Footer navigation Terms Privacy Security Status Docs Contact Manage cookies Do not share my personal information You can’t perform that action at this time.